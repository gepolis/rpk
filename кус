import sys
import json
import socket
import threading
from pathlib import Path
from PySide6.QtWidgets import (
    QApplication, QWidget, QListWidget, QLabel,
    QVBoxLayout, QHBoxLayout, QComboBox, QLineEdit,
    QMessageBox, QFrame, QTabWidget, QPushButton
)
from PySide6.QtCore import Qt

CONFIG_PATH = Path("rp_config.json")
FORMATS_PATH = "formats.json"
PHRASES_PATH = "rp_phrases.json"

DEFAULT_CONFIG = {
    "org": "Полиция",
    "rang": "Офицер",
    "name": "Анна",
    "server_ip": "109.73.204.176",
    "server_port": 12345
}

ACCESS_CODE = "6329"

class RPClient(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("RP Client 2025 — Клиент для RP")
        self.resize(900, 600)

        self.load_config()
        self.load_formats()
        self.load_phrases()

        self.sock = None
        self.connected = False
        self.flat_subcat_map = {}

        self.init_ui()
        # Соединение не делаем при старте — ждем пока пользователь нажмет кнопку

    def load_config(self):
        if not CONFIG_PATH.exists():
            with open(CONFIG_PATH, "w", encoding="utf-8") as f:
                json.dump(DEFAULT_CONFIG, f, indent=4, ensure_ascii=False)
            self.config = DEFAULT_CONFIG.copy()
            print("[INFO] Создан новый конфиг с настройками по умолчанию")
        else:
            try:
                with open(CONFIG_PATH, encoding="utf-8") as f:
                    self.config = json.load(f)
                print("[INFO] Конфиг загружен")
            except Exception as e:
                print("[ERROR] Ошибка загрузки конфига:", e)
                self.config = DEFAULT_CONFIG.copy()

    def save_config(self):
        try:
            with open(CONFIG_PATH, "w", encoding="utf-8") as f:
                json.dump(self.config, f, indent=4, ensure_ascii=False)
            print("[INFO] Конфиг сохранён")
        except Exception as e:
            print("[ERROR] Ошибка сохранения конфига:", e)

    def load_formats(self):
        try:
            with open(FORMATS_PATH, encoding="utf-8") as f:
                self.formats = json.load(f)
            print("[INFO] Форматы загружены")
        except Exception as e:
            print("[ERROR] Не удалось загрузить форматы:", e)
            self.formats = {}

    def load_phrases(self):
        try:
            with open(PHRASES_PATH, encoding="utf-8") as f:
                self.phrases = json.load(f)
            print("[INFO] Фразы загружены")
        except Exception as e:
            print("[ERROR] Не удалось загрузить фразы:", e)
            self.phrases = {}

    def init_ui(self):
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(10)

        self.tabs = QTabWidget()
        main_layout.addWidget(self.tabs)

        # --- Вкладка Основные настройки ---
        self.tab_main = QWidget()
        main_layout_main = QVBoxLayout(self.tab_main)
        main_layout_main.setContentsMargins(10, 10, 10, 10)
        main_layout_main.setSpacing(15)

        # Организация
        org_layout = QHBoxLayout()
        org_label = QLabel("Организация:")
        org_label.setFixedWidth(90)
        self.org_combo = QComboBox()
        self.org_combo.addItems([
            "Полиция", "ДПС", "ФСБ", "ФСО", "ФСИН", "ФССП", "Кошко-полиция"
        ])
        self.org_combo.setCurrentText(self.config.get("org", DEFAULT_CONFIG["org"]))
        self.org_combo.currentTextChanged.connect(lambda v: self.on_setting_changed("org", v))
        org_layout.addWidget(org_label)
        org_layout.addWidget(self.org_combo)
        main_layout_main.addLayout(org_layout)

        # Звание (Ранг)
        rang_layout = QHBoxLayout()
        rang_label = QLabel("Звание:")
        rang_label.setFixedWidth(90)
        self.rang_combo = QComboBox()
        self.rang_combo.addItems([
            "Офицер", "Сержант", "Лейтенант", "Капитан", "Майор",
            "Подполковник", "Полковник", "Рядовой", "Старший лейтенант"
        ])
        self.rang_combo.setCurrentText(self.config.get("rang", DEFAULT_CONFIG["rang"]))
        self.rang_combo.currentTextChanged.connect(lambda v: self.on_setting_changed("rang", v))
        rang_layout.addWidget(rang_label)
        rang_layout.addWidget(self.rang_combo)
        main_layout_main.addLayout(rang_layout)

        # Имя
        name_layout = QHBoxLayout()
        name_label = QLabel("Имя:")
        name_label.setFixedWidth(90)
        self.name_edit = QLineEdit()
        self.name_edit.setPlaceholderText("Ваше имя")
        self.name_edit.setText(self.config.get("name", DEFAULT_CONFIG["name"]))
        self.name_edit.textChanged.connect(lambda v: self.on_setting_changed("name", v))
        name_layout.addWidget(name_label)
        name_layout.addWidget(self.name_edit)
        main_layout_main.addLayout(name_layout)

        main_layout_main.addStretch()

        # --- Вкладка Настройки сервера ---
        self.tab_server = QWidget()
        main_layout_server = QVBoxLayout(self.tab_server)
        main_layout_server.setContentsMargins(10, 10, 10, 10)
        main_layout_server.setSpacing(15)

        self.access_label = QLabel("Введите код доступа для изменения настроек сервера:")
        self.access_label.setWordWrap(True)
        main_layout_server.addWidget(self.access_label)

        self.access_code_edit = QLineEdit()
        self.access_code_edit.setEchoMode(QLineEdit.Password)
        self.access_code_edit.setPlaceholderText("Код доступа")
        self.access_code_edit.textChanged.connect(self.check_access_code)
        main_layout_server.addWidget(self.access_code_edit)

        self.server_settings_container = QWidget()
        server_settings_layout = QVBoxLayout(self.server_settings_container)
        server_settings_layout.setContentsMargins(0, 0, 0, 0)
        server_settings_layout.setSpacing(12)

        server_ip_layout = QHBoxLayout()
        server_ip_label = QLabel("IP сервера:")
        server_ip_label.setFixedWidth(90)
        self.server_ip_edit = QLineEdit()
        self.server_ip_edit.setText(self.config.get("server_ip", DEFAULT_CONFIG["server_ip"]))
        server_ip_layout.addWidget(server_ip_label)
        server_ip_layout.addWidget(self.server_ip_edit)
        server_settings_layout.addLayout(server_ip_layout)

        server_port_layout = QHBoxLayout()
        server_port_label = QLabel("Порт сервера:")
        server_port_label.setFixedWidth(90)
        self.server_port_edit = QLineEdit()
        self.server_port_edit.setText(str(self.config.get("server_port", DEFAULT_CONFIG["server_port"])))
        server_port_layout.addWidget(server_port_label)
        server_port_layout.addWidget(self.server_port_edit)
        server_settings_layout.addLayout(server_port_layout)

        main_layout_server.addWidget(self.server_settings_container)
        self.server_settings_container.setVisible(False)

        # Кнопка подключения
        self.connect_button = QPushButton("Подключиться")
        self.connect_button.clicked.connect(self.on_connect_clicked)
        main_layout_server.addWidget(self.connect_button)

        # Статус подключения
        self.status_label = QLabel("Статус: Не подключено")
        main_layout_server.addWidget(self.status_label)

        # --- Основной UI с фразами ---
        self.phrases_tab = QWidget()
        phrases_layout = QVBoxLayout(self.phrases_tab)
        phrases_layout.setContentsMargins(10, 10, 10, 10)
        phrases_layout.setSpacing(10)

        lists_layout = QHBoxLayout()
        lists_layout.setSpacing(10)

        self.cat_list = QListWidget()
        self.cat_list.addItems(self.phrases.keys())
        self.cat_list.currentItemChanged.connect(self.on_category_changed)
        lists_layout.addWidget(self.create_group_widget("Категории", self.cat_list), 1)

        self.subcat_list = QListWidget()
        self.subcat_list.currentItemChanged.connect(self.on_subcategory_changed)
        lists_layout.addWidget(self.create_group_widget("Подкатегории / Подподкатегории", self.subcat_list), 1)

        self.phrase_list = QListWidget()
        self.phrase_list.itemDoubleClicked.connect(self.on_phrase_double_clicked)
        lists_layout.addWidget(self.create_group_widget("Фразы (двойной клик для отправки)", self.phrase_list), 2)

        phrases_layout.addLayout(lists_layout)

        self.tabs.addTab(self.phrases_tab, "Фразы")
        self.tabs.addTab(self.tab_main, "Настройки")
        self.tabs.addTab(self.tab_server, "Сервер")

        self.tabs.currentChanged.connect(self.on_tab_changed)

        if self.phrases:
            self.cat_list.setCurrentRow(0)
            first_cat = list(self.phrases.keys())[0]
            self.load_subcategories(first_cat)

        self.apply_styles()

    def create_group_widget(self, title, widget):
        container = QWidget()
        layout = QVBoxLayout(container)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(5)
        label = QLabel(title)
        label.setStyleSheet("font-weight: 600; font-size: 14px; color: #333333;")
        layout.addWidget(label)
        layout.addWidget(widget)
        return container

    def apply_styles(self):
        self.setStyleSheet("""
            QWidget {
                background-color: #fdfdfd;
                color: #222222;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                font-size: 14px;
            }
            QListWidget {
                background-color: #ffffff;
                border: 1px solid #ccc;
                padding: 4px;
            }
            QListWidget::item:selected {
                background-color: #1976d2;
                color: white;
            }
            QComboBox, QLineEdit {
                background-color: white;
                border: 1px solid #ccc;
                padding: 6px 8px;
                border-radius: 5px;
                font-size: 14px;
                color: #222222;
                min-width: 120px;
            }
            QComboBox:hover, QLineEdit:hover {
                border-color: #1976d2;
            }
            QLabel {
                color: #555555;
            }
            QPushButton {
                background-color: #1976d2;
                color: white;
                border-radius: 6px;
                padding: 8px 14px;
                font-weight: 600;
                font-size: 14px;
                border: none;
            }
            QPushButton:hover {
                background-color: #1565c0;
            }
        """)

    def check_access_code(self, text):
        if text == ACCESS_CODE:
            self.server_settings_container.setVisible(True)
            self.access_code_edit.setEnabled(False)
            self.access_label.setText("Доступ предоставлен. Вы можете изменить настройки сервера.")
        else:
            self.server_settings_container.setVisible(False)
            self.access_label.setText("Введите код доступа для изменения настроек сервера:")

    def on_connect_clicked(self):
        ip = self.server_ip_edit.text().strip()
        port_text = self.server_port_edit.text().strip()
        try:
            port = int(port_text)
        except:
            QMessageBox.warning(self, "Ошибка", "Порт должен быть числом")
            return

        self.config["server_ip"] = ip
        self.config["server_port"] = port
        self.save_config()

        # Закрываем предыдущее соединение, если есть
        if self.sock:
            try:
                self.sock.close()
            except:
                pass
            self.sock = None
            self.connected = False

        # Пытаемся подключиться
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.settimeout(5)
            self.sock.connect((ip, port))
            self.sock.settimeout(None)
            self.connected = True
            self.status_label.setText(f"Статус: Подключено к {ip}:{port}")
            self.sock.sendall(b"CLIENT_WITH_UI\n")
            threading.Thread(target=self.receive_loop, daemon=True).start()
        except Exception as e:
            self.status_label.setText(f"Статус: Ошибка подключения - {e}")
            self.connected = False
            self.sock = None

    def on_setting_changed(self, key, value):
        if key == "server_port":
            try:
                value = int(value)
            except:
                return
        self.config[key] = value
        self.save_config()
        if key in ("org", "rang", "name"):
            # обновим список фраз с подстановкой, если надо
            pass

    def on_tab_changed(self, index):
        # При смене вкладки если уходим с Серверной вкладки — сбрасываем доступ
        if self.tabs.widget(index) != self.tab_server:
            self.access_code_edit.setEnabled(True)
            self.access_code_edit.clear()
            self.server_settings_container.setVisible(False)
            self.access_label.setText("Введите код доступа для изменения настроек сервера:")

    def load_subcategories(self, category):
        self.subcat_list.clear()
        self.flat_subcat_map.clear()

        def recurse_subcats(d, prefix=""):
            for k, v in d.items():
                if isinstance(v, dict):
                    # Если есть вложенные словари — добавляем как подкатегорию
                    # Если подкатегория содержит списки (фразы) — добавляем её, иначе идём глубже
                    if any(isinstance(val, list) for val in v.values()):
                        label = prefix + k
                        self.flat_subcat_map[label] = v
                        self.subcat_list.addItem(label)
                    else:
                        recurse_subcats(v, prefix + k + " > ")
                elif isinstance(v, list):
                    label = prefix + k
                    self.flat_subcat_map[label] = v
                    self.subcat_list.addItem(label)

        subcats = self.phrases.get(category, {})
        recurse_subcats(subcats)

    def on_category_changed(self, current, previous):
        self.phrase_list.clear()
        if not current:
            return
        category = current.text()
        self.load_subcategories(category)
        # Автовыбор первой подкатегории
        if self.subcat_list.count() > 0:
            self.subcat_list.setCurrentRow(0)

    def on_subcategory_changed(self, current, previous):
        self.phrase_list.clear()
        if not current:
            return
        label = current.text()
        data = self.flat_subcat_map.get(label)
        if not data:
            return
        phrases = []
        if isinstance(data, dict):
            for val in data.values():
                if isinstance(val, list):
                    phrases.extend(val)
        elif isinstance(data, list):
            phrases = data
        self.phrase_list.addItems(phrases)

    def on_phrase_double_clicked(self, item):
        text = item.text()
        cat = self.cat_list.currentItem().text()
        subcat_label = self.subcat_list.currentItem().text()
        prefix, suffix = self.get_format_prefix_suffix(cat, subcat_label)
        text_to_send = self.apply_variables(prefix + text + suffix)
        print(f"[SEND] {text_to_send}")
        self.send_to_server(text_to_send)

    def get_format_prefix_suffix(self, category, subcategory_label):
        parts = subcategory_label.split(" > ")
        subcat = parts[-1]
        cat_fmt = self.formats.get(category, {})
        fmt = None
        if subcat in cat_fmt:
            fmt = cat_fmt[subcat]
        else:
            if "Фразы" in cat_fmt:
                fmt = cat_fmt["Фразы"]
        if fmt:
            prefix = fmt.get("prefix", "")
            suffix = fmt.get("suffix", "")
        else:
            prefix = ""
            suffix = ""
        return prefix, suffix

    def apply_variables(self, text):
        for key, val in self.config.items():
            text = text.replace("{" + key + "}", str(val))
        return text

    def send_to_server(self, message: str):
        if self.sock and self.connected:
            try:
                self.sock.sendall((message + "\n").encode("utf-8"))
            except Exception as e:
                print("[ERROR] Ошибка отправки сообщения:", e)
        else:
            print("[WARN] Не подключено к серверу.")

    def receive_loop(self):
        try:
            while self.connected:
                data = self.sock.recv(1024)
                if not data:
                    break
                msg = data.decode("utf-8").strip()
                print("[RECV]", msg)
        except Exception as e:
            print("[ERROR] Ошибка приема:", e)
        finally:
            self.connected = False
            self.status_label.setText("Статус: Отключено от сервера")
            self.sock = None

if __name__ == "__main__":
    app = QApplication(sys.argv)
    client = RPClient()
    client.show()
    sys.exit(app.exec())
